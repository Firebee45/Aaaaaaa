<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Minecraft Portal & Area Map Editor</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background-color: #111;
      color: #ddd;
      max-width: 950px;
      margin: 20px auto;
    }
    form, .button-group {
      margin-bottom: 10px;
    }
    label, input, button {
      font-size: 14px;
      margin: 2px;
      vertical-align: middle;
    }
    input[type="number"], input[type="text"] {
      width: 100px;
      padding: 2px;
    }
    .portal-entry {
      margin: 4px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .portal-entry label {
      flex-grow: 1;
      cursor: pointer;
    }
    .delete-btn {
      cursor: pointer;
      background: #700;
      border: none;
      color: #ddd;
      padding: 2px 6px;
      font-weight: bold;
      border-radius: 3px;
      user-select: none;
    }
    #plot {
      width: 100%;
      height: 600px;
    }
    /* Modal styles */
    #modalOverlay {
      display: none;
      position: fixed;
      top:0; left:0; right:0; bottom:0;
      background: rgba(0,0,0,0.75);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #modalContent {
      background: #222;
      border: 1px solid #555;
      padding: 15px;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      color: #ddd;
      font-family: monospace;
      white-space: pre-wrap;
      word-break: break-all;
      position: relative;
    }
    #modalContent textarea {
      width: 100%;
      height: 300px;
      background: #111;
      color: #ddd;
      border: 1px solid #555;
      resize: vertical;
      font-family: monospace;
      font-size: 14px;
      padding: 5px;
    }
    #modalCloseBtn {
      position: absolute;
      top: 5px;
      right: 8px;
      background: #700;
      color: #ddd;
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      font-weight: bold;
      border-radius: 3px;
      user-select: none;
    }
  </style>
</head>
<body>

<h2>Minecraft Portal & Area Map Editor</h2>

<form id="coordForm">
  <label>X:</label><input type="number" id="x" required />
  <label>Z:</label><input type="number" id="z" required />
  <label>Label:</label><input type="text" id="label" placeholder="Enter label" />
  <button type="submit">Add Portal</button>
</form>

<form id="areaForm">
  <label>X1:</label><input type="number" id="x1" required />
  <label>Z1:</label><input type="number" id="z1" required /><br />
  <label>X2:</label><input type="number" id="x2" required />
  <label>Z2:</label><input type="number" id="z2" required />
  <label>Label:</label><input type="text" id="areaLabel" placeholder="Enter label" />
  <button type="submit">Add Area</button>
</form>

<div class="button-group">
  <button onclick="clearAll()">Clear All</button>
  <button onclick="downloadPNG()">Download PNG</button>
  <button id="importJsonBtn">Import JSON</button>
  <button id="exportJsonBtn">Export JSON</button>
  <button id="updateJsonBtn">Update JSON in Repo</button>
</div>

<div id="portalList"></div>
<div id="plot"></div>

<!-- Modal for import/export JSON -->
<div id="modalOverlay">
  <div id="modalContent">
    <button id="modalCloseBtn" title="Close">âœ–</button>
    <div id="modalBody"></div>
  </div>
</div>

<script>
  // GitHub repo info for JSON update
  const rawDataURL = 'https://raw.githubusercontent.com/Firebee45/Aaaaaaa/main/minecraftMapData.json';
  const apiRepoOwner = 'Firebee45';
  const apiRepoName = 'Aaaaaaa';
  const apiFilePath = 'minecraftMapData.json';
  const apiBranch = 'main';

  let portals = [], areas = [];
  let fileSHA = null; // will store SHA of the file for updates

  // Modal Elements
  const modalOverlay = document.getElementById('modalOverlay');
  const modalBody = document.getElementById('modalBody');
  const modalCloseBtn = document.getElementById('modalCloseBtn');

  modalCloseBtn.onclick = () => { hideModal(); };
  modalOverlay.onclick = (e) => {
    if (e.target === modalOverlay) hideModal();
  };

  function showModal(contentHtml) {
    modalBody.innerHTML = contentHtml;
    modalOverlay.style.display = 'flex';
  }
  function hideModal() {
    modalOverlay.style.display = 'none';
    modalBody.innerHTML = '';
  }

  // Load saved data from localStorage first
  const saved = localStorage.getItem('minecraftMapData');
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      if (parsed.portals) portals = parsed.portals;
      if (parsed.areas) areas = parsed.areas;
    } catch {}
  }

  // Try to load from GitHub raw JSON on page load to get latest
  fetch(rawDataURL)
    .then(res => {
      if (!res.ok) throw new Error('Not found on GitHub');
      return res.json();
    })
    .then(json => {
      portals = json.portals || [];
      areas = json.areas || [];
      saveData(); // sync to localStorage
      updateList();
      updatePlot();
      getFileSHA();
    })
    .catch(() => {
      // If failed to load from GitHub, just load from localStorage fallback
      updateList();
      updatePlot();
      getFileSHA();
    });

  function getFileSHA() {
    // Get the current file SHA needed for GitHub API update
    fetch(`https://api.github.com/repos/${apiRepoOwner}/${apiRepoName}/contents/${apiFilePath}?ref=${apiBranch}`)
      .then(res => res.json())
      .then(data => {
        if (data.sha) fileSHA = data.sha;
      })
      .catch(() => {
        console.warn('Could not get file SHA from GitHub');
      });
  }

  const coordForm = document.getElementById("coordForm");
  const areaForm = document.getElementById("areaForm");

  coordForm.addEventListener("submit", e => {
    e.preventDefault();
    const x = +document.getElementById("x").value;
    const z = +document.getElementById("z").value;
    const label = document.getElementById("label").value.trim() || `Portal ${portals.length+1}`;
    portals.push({ x, z, label, enabled: true });
    coordForm.reset();
    saveData();
    updateList();
    updatePlot();
  });

  areaForm.addEventListener("submit", e => {
    e.preventDefault();
    const x1 = +document.getElementById("x1").value;
    const z1 = +document.getElementById("z1").value;
    const x2 = +document.getElementById("x2").value;
    const z2 = +document.getElementById("z2").value;
    const label = document.getElementById("areaLabel").value.trim() || `Area ${areas.length+1}`;
    areas.push({ x1, z1, x2, z2, label, enabled: true });
    areaForm.reset();
    saveData();
    updateList();
    updatePlot();
  });

  function updateList() {
    const div = document.getElementById("portalList");
    div.innerHTML = '';

    portals.forEach((p,i) => {
      const wrapper = document.createElement('div');
      wrapper.className = 'portal-entry';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = p.enabled;
      checkbox.onchange = () => { toggleP(i); };
      wrapper.appendChild(checkbox);

      const label = document.createElement('label');
      label.textContent = `ðŸŸ£ ${p.label} (${p.x},${p.z})`;
      label.onclick = () => {
        checkbox.checked = !checkbox.checked;
        toggleP(i);
      };
      wrapper.appendChild(label);

      const delBtn = document.createElement('button');
      delBtn.className = 'delete-btn';
      delBtn.textContent = 'âœ–';
      delBtn.onclick = () => {
        portals.splice(i,1);
        saveData();
        updateList();
        updatePlot();
      };
      wrapper.appendChild(delBtn);

      div.appendChild(wrapper);
    });

    areas.forEach((a,i) => {
      const wrapper = document.createElement('div');
      wrapper.className = 'portal-entry';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = a.enabled;
      checkbox.onchange = () => { toggleA(i); };
      wrapper.appendChild(checkbox);

      const label = document.createElement('label');
      label.textContent = `ðŸŸ¥ ${a.label} [(${a.x1},${a.z1})â†’(${a.x2},${a.z2})]`;
      label.onclick = () => {
        checkbox.checked = !checkbox.checked;
        toggleA(i);
      };
      wrapper.appendChild(label);

      const delBtn = document.createElement('button');
      delBtn.className = 'delete-btn';
      delBtn.textContent = 'âœ–';
      delBtn.onclick = () => {
        areas.splice(i,1);
        saveData();
        updateList();
        updatePlot();
      };
      wrapper.appendChild(delBtn);

      div.appendChild(wrapper);
    });
  }

  function toggleP(i) {
    portals[i].enabled = !portals[i].enabled;
    saveData();
    updatePlot();
  }
  function toggleA(i) {
    areas[i].enabled = !areas[i].enabled;
    saveData();
    updatePlot();
  }
  function clearAll() {
    portals = [];
    areas = [];
    saveData();
    updateList();
    updatePlot();
  }

  function saveData() {
    localStorage.setItem('minecraftMapData', JSON.stringify({ portals, areas }));
  }

  function downloadPNG() {
    Plotly.downloadImage('plot', {
      format: 'png', filename: 'minecraft_map',
      height: 600, width: 900, scale: 2
    });
  }

  function calcDtick(range) {
    const base = 16;
    const exp = Math.floor(Math.log2(range / base));
    return base * Math.pow(2, Math.max(exp,0));
  }

  function updatePlot() {
    const data = [];
    const ps = portals.filter(p => p.enabled);
    if (ps.length) {
      data.push({
        x: ps.map(p => p.x), y: ps.map(p => p.z),
        text: ps.map(p => `${p.label} (${p.x},${p.z})`),
        mode: 'markers+text', textposition: 'top center',
        marker: { size: 10, color: 'magenta' }, type: 'scatter', name: 'Portals'
      });
    }

    areas.filter(a => a.enabled).forEach(a => {
      const xMin = Math.min(a.x1, a.x2), xMax = Math.max(a.x1, a.x2);
      const zMin = Math.min(a.z1, a.z2), zMax = Math.max(a.z1, a.z2);
      data.push({
        x: [xMin, xMax, xMax, xMin, xMin],
        y: [zMin, zMin, zMax, zMax, zMin],
        mode: 'lines', line: { color: 'red', width: 2 },
        showlegend: false, type: 'scatter'
      });
    });

    // Area labels
    const areaLabelData = areas.filter(a => a.enabled).map(a => {
      const xMin = Math.min(a.x1, a.x2), xMax = Math.max(a.x1, a.x2);
      const zMax = Math.max(a.z1, a.z2);
      return {
        x: [(xMin + xMax) / 2],
        y: [zMax + 8],
        text: [a.label],
        mode: 'text',
        textposition: 'top center',
        textfont: { color: 'red', size: 14 },
        showlegend: false,
        type: 'scatter',
      };
    });
    data.push(...areaLabelData);

    const xs = [...ps.map(p => p.x), ...areas.map(a => a.x1).concat(areas.map(a => a.x2))];
    const zs = [...ps.map(p => p.z), ...areas.map(a => a.z1).concat(areas.map(a => a.z2))];
    const minX = Math.min(...xs, 0) - 32, maxX = Math.max(...xs, 0) + 32;
    const minZ = Math.min(...zs, 0) - 32, maxZ = Math.max(...zs, 0) + 32;
    const xrange = maxX - minX, zrange = maxZ - minZ;
    const dt = calcDtick(Math.max(xrange, zrange));

    Plotly.newPlot('plot', data, {
      paper_bgcolor: '#111', plot_bgcolor: '#111', font: { color: '#ddd' },
      xaxis: { title: 'X', showgrid: true, gridcolor: '#333', dtick: dt, range: [minX, maxX] },
      yaxis: { title: 'Z', showgrid: true, gridcolor: '#333', dtick: dt, scaleanchor: 'x', scaleratio: 1, range: [minZ, maxZ] },
      dragmode: false,
      modebar: { remove: ['zoom2d', 'lasso2d', 'select2d', 'zoomIn2d', 'zoomOut2d'], orientation: 'v' }
    }, { responsive: true });
  }

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Minecraft Portal & Area Map</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      background-color: #111;
      color: #ddd;
      max-width: 950px;
      margin: 20px auto;
    }
    form, .button-group {
      margin-bottom: 10px;
    }
    label, input, button {
      font-size: 14px;
      margin: 2px;
      vertical-align: middle;
    }
    input[type="number"], input[type="text"] {
      width: 100px;
      padding: 2px;
    }
    .portal-entry {
      margin: 4px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #plot {
      width: 100%;
      height: 600px;
    }
    .delete-btn {
      background: #a33;
      color: white;
      border: none;
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
    }
    .delete-btn:hover {
      background: #d55;
    }
  </style>
</head>
<body>

<h2>Minecraft Portal & Area Map</h2>

<form id="coordForm">
  <label>X:</label><input type="number" id="x" required />
  <label>Z:</label><input type="number" id="z" required />
  <label>Label:</label><input type="text" id="label" placeholder="Enter label" />
  <button type="submit">Add Portal</button>
</form>

<form id="areaForm">
  <label>X1:</label><input type="number" id="x1" required />
  <label>Z1:</label><input type="number" id="z1" required /><br />
  <label>X2:</label><input type="number" id="x2" required />
  <label>Z2:</label><input type="number" id="z2" required />
  <label>Label:</label><input type="text" id="areaLabel" placeholder="Enter label" />
  <button type="submit">Add Area</button>
</form>

<div class="button-group">
  <button onclick="clearAll()">Clear All</button>
  <button onclick="downloadPNG()">Download PNG</button>
</div>

<div id="portalList"></div>
<div id="plot"></div>

<script>
  let portals = [];
  let areas = [];

  // Load saved data from localStorage if available
  const savedPortals = localStorage.getItem('minecraftPortals');
  const savedAreas = localStorage.getItem('minecraftAreas');
  if (savedPortals) portals = JSON.parse(savedPortals);
  if (savedAreas) areas = JSON.parse(savedAreas);

  const coordForm = document.getElementById("coordForm");
  const areaForm = document.getElementById("areaForm");

  coordForm.addEventListener("submit", e => {
    e.preventDefault();
    const x = +document.getElementById("x").value;
    const z = +document.getElementById("z").value;
    const label = document.getElementById("label").value.trim() || `Portal ${portals.length + 1}`;
    portals.push({ x, z, label, enabled: true });
    saveData();
    coordForm.reset();
    updateList();
    updatePlot();
  });

  areaForm.addEventListener("submit", e => {
    e.preventDefault();
    const x1 = +document.getElementById("x1").value;
    const z1 = +document.getElementById("z1").value;
    const x2 = +document.getElementById("x2").value;
    const z2 = +document.getElementById("z2").value;
    const label = document.getElementById("areaLabel").value.trim() || `Area ${areas.length + 1}`;
    areas.push({ x1, z1, x2, z2, label, enabled: true });
    saveData();
    areaForm.reset();
    updateList();
    updatePlot();
  });

  function updateList() {
    const div = document.getElementById("portalList");
    div.innerHTML = '';

    portals.forEach((p, i) => {
      const portalDiv = document.createElement('div');
      portalDiv.className = 'portal-entry';
      portalDiv.innerHTML = `
        <input type="checkbox" ${p.enabled ? 'checked' : ''} onchange="togglePortal(${i})" />
        ðŸŸ£ ${p.label} (${p.x},${p.z})
        <button class="delete-btn" onclick="deletePortal(${i})" title="Delete Portal">âœ•</button>
      `;
      div.appendChild(portalDiv);
    });

    areas.forEach((a, i) => {
      const areaDiv = document.createElement('div');
      areaDiv.className = 'portal-entry';
      areaDiv.innerHTML = `
        <input type="checkbox" ${a.enabled ? 'checked' : ''} onchange="toggleArea(${i})" />
        ðŸŸ¥ ${a.label} [(${a.x1},${a.z1})â†’(${a.x2},${a.z2})]
        <button class="delete-btn" onclick="deleteArea(${i})" title="Delete Area">âœ•</button>
      `;
      div.appendChild(areaDiv);
    });
  }

  function togglePortal(i) {
    portals[i].enabled = !portals[i].enabled;
    saveData();
    updatePlot();
  }

  function toggleArea(i) {
    areas[i].enabled = !areas[i].enabled;
    saveData();
    updatePlot();
  }

  function deletePortal(i) {
    portals.splice(i, 1);
    saveData();
    updateList();
    updatePlot();
  }

  function deleteArea(i) {
    areas.splice(i, 1);
    saveData();
    updateList();
    updatePlot();
  }

  function clearAll() {
    portals = [];
    areas = [];
    saveData();
    updateList();
    updatePlot();
  }

  function downloadPNG() {
    Plotly.downloadImage('plot', {
      format: 'png',
      filename: 'minecraft_map',
      height: 600,
      width: 900,
      scale: 2
    });
  }

  function saveData() {
    localStorage.setItem('minecraftPortals', JSON.stringify(portals));
    localStorage.setItem('minecraftAreas', JSON.stringify(areas));
  }

  function calcDtick(range) {
    const base = 16;
    const exp = Math.floor(Math.log2(range / base));
    return base * Math.pow(2, Math.max(exp, 0));
  }

  // Helper to detect rectangle overlap for stacking labels
  function rectsOverlap(r1, r2) {
    return !(r1.xMax < r2.xMin || r1.xMin > r2.xMax || r1.yMax < r2.yMin || r1.yMin > r2.yMax);
  }

  function updatePlot() {
    const data = [];
    const enabledPortals = portals.filter(p => p.enabled);
    if (enabledPortals.length) {
      data.push({
        x: enabledPortals.map(p => p.x),
        y: enabledPortals.map(p => p.z),
        text: enabledPortals.map(p => `${p.label} (${p.x},${p.z})`),
        mode: 'markers+text',
        textposition: 'top center',
        marker: { size: 10, color: 'magenta' },
        type: 'scatter',
        name: 'Portals',
      });
    }

    // Draw areas (rectangles)
    areas.filter(a => a.enabled).forEach(a => {
      const xMin = Math.min(a.x1, a.x2);
      const xMax = Math.max(a.x1, a.x2);
      const zMin = Math.min(a.z1, a.z2);
      const zMax = Math.max(a.z1, a.z2);

      data.push({
        x: [xMin, xMax, xMax, xMin, xMin],
        y: [zMin, zMin, zMax, zMax, zMin],
        mode: 'lines',
        line: { color: 'red', width: 2 },
        showlegend: false,
        type: 'scatter',
      });
    });

    // Position area labels above boxes, stacking them if overlapping
    const labelRects = [];
    const labelData = [];

    areas.filter(a => a.enabled).forEach(a => {
      const xMin = Math.min(a.x1, a.x2);
      const xMax = Math.max(a.x1, a.x2);
      const zMax = Math.max(a.z1, a.z2);

      let labelX = (xMin + xMax) / 2;
      let labelY = zMax + 8; // vertical offset above area box

      const labelWidth = (xMax - xMin) * 0.8 || 10; // fallback width
      const labelHeight = 6;

      let currentRect = {
        xMin: labelX - labelWidth / 2,
        xMax: labelX + labelWidth / 2,
        yMin: labelY - labelHeight,
        yMax: labelY,
      };

      const stackStep = labelHeight + 2;
      let tries = 0;

      while (labelRects.some(r => rectsOverlap(r, currentRect))) {
        labelY += stackStep;
        currentRect.yMin = labelY - labelHeight;
        currentRect.yMax = labelY;
        tries++;
        if (tries > 20) break;
      }

      labelRects.push({ ...currentRect });

      labelData.push({
        x: [labelX],
        y: [labelY],
        text: [a.label],
        mode: 'text',
        textposition: 'top center',
        textfont: { color: 'red', size: 14 },
        showlegend: false,
        type: 'scatter',
      });
    });

    data.push(...labelData);

    // Calculate ranges
    const xs = [
      ...enabledPortals.map(p => p.x),
      ...areas.flatMap(a => [a.x1, a.x2])
    ];
    const zs = [
      ...enabledPortals.map(p => p.z),
      ...areas.flatMap(a => [a.z1, a.z2])
    ];

    const minX = Math.min(...xs, 0) - 32;
    const maxX = Math.max(...xs, 0) + 32;
    const minZ = Math.min(...zs, 0) - 32;
    const maxZ = Math.max(...zs, 0) + 32;

    const xrange = maxX - minX;
    const zrange = maxZ - minZ;
    const dt = calcDtick(Math.max(xrange, zrange));

    Plotly.newPlot('plot', data, {
      paper_bgcolor: '#111',
      plot_bgcolor: '#111',
      font: { color: '#ddd' },
      xaxis: {
        title: 'X',
        showgrid: true,
        gridcolor: '#333',
        dtick: dt,
        range: [minX, maxX],
      },
      yaxis: {
        title: 'Z',
        showgrid: true,
        gridcolor: '#333',
        dtick: dt,
        scaleanchor: 'x',
        scaleratio: 1,
        range: [minZ, maxZ],
      },
      dragmode: false,
      modebar: {
        remove: ['zoom2d', 'lasso2d', 'select2d', 'zoomIn2d', 'zoomOut2d'],
        orientation: 'v',
      },
    }, { responsive: true });
  }

  // Initial update on load
  updateList();
  updatePlot();

  // Expose functions to window for inline handlers
  window.togglePortal = togglePortal;
  window.toggleArea = toggleArea;
  window.deletePortal = deletePortal;
  window
